<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WebXR AR Dome v2</title>
  <style>
    body { margin:0; overflow:hidden; font-family: sans-serif; }
    #ui, #flashBtn {
      position: absolute; z-index: 10; background: rgba(255,255,255,0.9); padding:10px; border-radius:8px;
    }
    #ui { top:10px; left:10px; }
    #flashBtn { top:10px; right:10px; cursor: pointer; }
    button { display:block; width:100%; margin-top:8px; }
    .ar-button { position: absolute !important; bottom: 20px !important; left: calc(50% - 50px) !important; }
  </style>
</head>
<body>
  <div id="ui">
    <label>Target Size (mm): <input type="number" id="targetSize" value="100" /></label><br/>
    <label>Multiplier: <input type="number" id="sizeMultiplier" value="3" step="0.1"/></label><br/>
    <label>Azimuths (deg): <input type="text" id="azimuths" value="0,45,90,135,180,225,270,315"/></label><br/>
    <label>Elevations (deg): <input type="text" id="elevations" value="30,45,60"/></label><br/>
    <button id="genBtn">Generate Dome</button>
  </div>
  <button id="flashBtn">Flash OFF</button>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
    import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/ARButton.js';
    import { DragControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/DragControls.js';

    let camera, scene, renderer, controller;
    let domeGroup = null;
    let raycaster = new THREE.Raycaster();
    let pointer = new THREE.Vector2();
    let videoTrack = null, torchOn = false;
    const ui = document.getElementById('ui');
    const flashBtn = document.getElementById('flashBtn');

    init();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera();
      renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      // ARButton with hit-test for AR session
      const arButton = ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] });
      arButton.classList.add('ar-button');
      document.body.appendChild(arButton);

      // Controller for future use
      controller = renderer.xr.getController(0);
      scene.add(controller);

      window.addEventListener('click', onClick);
      document.getElementById('genBtn').addEventListener('click', generateDome);

      setupTorch();

      renderer.setAnimationLoop(() => {
        renderer.render(scene, camera);
      });
    }

    async function setupTorch() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'environment' }});
        const [track] = stream.getVideoTracks();
        const caps = track.getCapabilities();
        if (caps.torch) {
          videoTrack = track;
          flashBtn.disabled = false;
          flashBtn.addEventListener('click', toggleFlash);
        } else {
          flashBtn.textContent = 'No Torch';
        }
      } catch(err) {
        flashBtn.textContent = 'No Torch';
      }
    }

    function toggleFlash(){
      if (!videoTrack) return;
      torchOn = !torchOn;
      videoTrack.applyConstraints({ advanced:[{ torch: torchOn }] })
        .then(() => flashBtn.textContent = torchOn? 'Flash ON':'Flash OFF')
        .catch(()=> flashBtn.textContent='Error');
    }

    function onClick(e){
      pointer.x = (e.clientX/window.innerWidth)*2-1;
      pointer.y = -(e.clientY/window.innerHeight)*2+1;
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(scene.children,true);
      if (hits.length>0 && hits[0].object.userData.label) {
        alert(hits[0].object.userData.label);
      }
    }

    function generateDome(){
      const ts = parseFloat(document.getElementById('targetSize').value);
      const mul = parseFloat(document.getElementById('sizeMultiplier').value);
      const azs = document.getElementById('azimuths').value.split(',').map(n=>parseFloat(n));
      const els = document.getElementById('elevations').value.split(',').map(n=>parseFloat(n));
      const radius = (ts/1000)*mul;
      if (domeGroup) scene.remove(domeGroup);
      domeGroup = new THREE.Group();

      const mat = new THREE.MeshStandardMaterial({color:0x000000,transparent:true,opacity:0.3,side:THREE.DoubleSide});
      domeGroup.add(new THREE.Mesh(new THREE.SphereGeometry(radius,32,16,0,Math.PI*2,0,Math.PI/2), mat));
      domeGroup.add(new THREE.Mesh(new THREE.SphereGeometry(radius-0.01,32,16,0,Math.PI*2,0,Math.PI/2), mat));

      const geo = new THREE.SphereGeometry(0.03,16,16);
      const mat2 = new THREE.MeshBasicMaterial({color:0xff0000});
      azs.forEach(az=> els.forEach(el=>{
        const theta = THREE.MathUtils.degToRad(az);
        const phi = THREE.MathUtils.degToRad(el);
        const x = radius*Math.cos(phi)*Math.sin(theta);
        const y = radius*Math.sin(phi);
        const z = radius*Math.cos(phi)*Math.cos(theta);
        const m = new THREE.Mesh(geo,mat2);
        m.position.set(x,y,z);
        m.userData.label = `${az}° / ${el}°`;
        domeGroup.add(m);
      }));

      // Place 0.5m in front
      const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
      domeGroup.position.copy(camera.position).add(dir.multiplyScalar(0.5));
      scene.add(domeGroup);
      new DragControls([domeGroup], camera, renderer.domElement);
    }
  </script>
</body>
</html>
